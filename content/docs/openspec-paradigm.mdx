---
title: OpenSpec：AI 时代真正可执行的工程规范体系
description: 探索 AI 时代下的新型开发范式和方法论
---

<iframe 
  src="//player.bilibili.com/player.html?bvid=BV1FnmzBFEmH&page=1" 
  scrolling="no" 
  border="0" 
  frameborder="no" 
  framespacing="0" 
  allowfullscreen="true"
  style={{ width: '100%', height: '500px' }}
/>

![OpenSpec 核心架构：从 Prompt 抽卡到 Spec 契约](/images/openspec.png)

很多人第一次听到 OpenSpec，会下意识问一句：

> “这不就是写文档吗？”

如果只是写文档，它不值得你花任何额外精力。
**OpenSpec 真正重要的地方在于：它是“给 AI 执行的工程规范”，而不是给人看的说明书。**

这是一个本质差异。

---

## 一、先给 OpenSpec 一个严格定义

我们先给 OpenSpec 下一个**工程级定义**：

> **OpenSpec 是一组结构化、可解析、可复用、可被 AI 严格遵守的工程契约，用来描述系统“必须如何被实现”，而不是“希望它怎么做”。**

这句话里，每个词都很重要：

* **结构化**：不是散文，不是口头描述
* **可解析**：AI 能稳定理解，不靠猜
* **可复用**：能反复喂给模型
* **工程契约**：不是建议，而是约束

如果你写的东西：

* AI 每次理解都不一样
* 需要你反复解释
* 不能直接驱动代码生成

那它就不配叫 OpenSpec。

---

## 二、为什么 AI 编程“必然”需要 OpenSpec

这是一个很多人没想清楚的底层事实：

> **AI 不是在理解你的“意图”，它是在寻找“可执行约束”。**

人类工程师可以：

* 主动补全上下文
* 读空气
* 理解隐含约定

AI 不会。

一旦你不给它一个**明确、封闭、无歧义的约束空间**，它就只能依赖概率分布。

这就是为什么：

* Prompt 越写越长
* 结果却越来越不稳定
* 改一个地方，别的地方全崩

**OpenSpec 的存在，本质上是为了给 AI 一个“不可自由发挥的边界”。**

---

## 三、OpenSpec 不是一种格式，而是三层规范的组合

很多人会问：

> “OpenSpec 是不是一种新 DSL？”

不是。

OpenSpec 从一开始就**刻意避免**发明新语言。
它只使用三种已经被工程界验证过的表达方式，但赋予它们新的角色。

---

### 第一层：接口与数据规范（Schema Layer）

这一层解决的是一个最基础的问题：

> **数据到底长什么样？**

典型形式包括：

* OpenAPI
* JSON Schema
* TypeScript 类型定义

但在 OpenSpec 里，它们不只是“类型提示”，而是：

* 唯一合法的数据形态
* 状态流转的边界
* 前后端、AI 之间的硬约束

**关键原则：**

> 如果一个字段没写进 Spec，那它就不应该出现在代码里。

这一步，直接消灭 80% 的“字段幻觉”。

---

### 第二层：结构与规则规范（Structure Layer）

这一层，决定的是：

> **系统是如何被拆解的？**

它通常是结构化 Markdown，描述：

* 模块划分
* 文件结构
* 组件职责
* 层级边界

比如你要明确告诉 AI：

* 哪些是 pure logic
* 哪些是 UI
* 哪些模块禁止互相依赖
* 状态只能从哪里流入

**注意：**
你不是在“建议”，而是在“划红线”。

AI 一旦越界，你可以明确指出：

> “你违反了 Spec 第 X 条。”

这是一个质变。

---

### 第三层：流程与决策规范（Process Layer）

这是最容易被忽略，但**最拉开差距**的一层。

这一层描述的是：

* 业务流程
* 状态机
* 决策顺序
* 异常处理逻辑

形式可以是：

* 伪代码
* 状态流转表
* 明确的步骤列表

为什么这一层重要？

因为**AI 最容易“帮你多想一步”**。
而工程里，**多想一步，往往就是错的**。

---

## 四、OpenSpec 和 Prompt 的根本关系

这里我们必须说一句可能刺耳的话：

> **Prompt 在 OpenSpec 面前，是二等公民。**

在 Spec 驱动的体系里：

* Prompt 不再承载规则
* Prompt 只负责“调用意图”

比如一句非常短的 Prompt：

> “基于当前 OpenSpec，实现用户输入到图表渲染的完整链路，只生成缺失文件。”

真正决定行为的，不是 Prompt，而是 Spec。

这就是为什么：

* Prompt 可以极短
* 结果却极稳定

---

## 五、OpenSpec 驱动下的工作流变化（非常关键）

我们把流程讲清楚。

### 传统 AI 编程流

```
需求 → 想一想 → 写 Prompt → 生成代码 → 不对 → 改 Prompt
```

这是一个**概率闭环**。

---

### OpenSpec 驱动流

```
需求 → 写 Spec → 审 Spec → AI 实现 → 对齐 Spec
```

这是一个**确定性闭环**。

你会发现一个变化：

> **错误被前移到了设计阶段，而不是实现阶段。**

这正是成熟工程体系的标志。

---

## 六、为什么 OpenSpec 会“逼迫”你成为更好的工程师

这里说一句非常现实的话。

OpenSpec 不适合：

* 对系统没想清楚的人
* 想靠 AI 直接“帮我搞定”的人
* 不愿意做设计决策的人

因为它会强迫你回答这些问题：

* 数据模型到底是什么？
* 模块边界在哪？
* 哪些允许变化，哪些绝不允许？
* 决策顺序是否唯一？

**AI 不会替你做架构决策。
它只会放大你已有的设计质量。**

---

## 七、OpenSpec 是工程资产，而不是辅助材料

这是很多人最后才意识到的一点。

一旦你把 OpenSpec 当真：

* 它应该进 Git
* 它应该有版本
* 它应该被 Review
* 它应该随着需求演进

你会发现：

> 代码反而变成了“可再生资源”。

真正不可替代的，是 Spec 本身。

---

## 八、一句话总结 OpenSpec 的工程意义

如果一定要用一句话总结：

> **OpenSpec 是把“人与 AI 的协作”，拉回到工程可控性的唯一现实路径。**

它不是为了让 AI 更自由，
而是为了让系统**不再失控**。

